# 继承

继承是多态的前提，如果没有继承，就没有多态

继承主要解决的是`共性抽取`

继承关系当中的特点：
1. 子类可以拥有父类的内容
2. 子类还可以拥有自己专有的内容 

父子类的继承关系当中，如果成员变量重名，则创建子类对象时：
直接通过子类对象访问成员变量：
    等号左边是谁，就优先用谁，没有则向上找
间接通过成员方法访问变量：
    这个方法是谁的，就优先`就近`用谁的。

不同的区域重名：`就近原则`

本类的成员变量
父类的成员变量
本类成员方法当中的局部变量

就近原则是默认的原则，那如果在本类的成员方法中想访问其他地方呢？

有this,super：
this.var_name; 子类成员变量
super.var_name; 父类成员变量

### 重写与重载

重写：在`继承关系`的当中，方法的`名称一样`，参数`列表也一样`。
重载：方法的名称一样，参数`列表不一样`

方法的覆盖重写特点：创建的是子类对象，就先用子类对象

`注意`：
1. 必须保证父子类之间的方法名称相同，参数列表也相同
@override 写在方法前面，用来`检测`是否是重写
就算`不写`，满足也同样进行覆盖重写
2.  子类方法的`返回值`必须`小于等于`父类方法的返回值范围
java.lang.Object类时所有类的公共最高父类，java.lang.String是Object的子类
3. 子类方法的`权限修饰符`必须`大于等于`父类方法的权限修饰符 

## 父子类构造方法的特点：

1. 子类构造方法当中有一个`默认`隐含的`super()调用`,一定是先调用父类的构造，后执行子类的构造
2. 可以通过super在子类调用构造父类重载构造。
3. super的父类构造调用，必须是子类构造方法的第一个语句。

子类必须调用父类构造方法，不写默认赠送super()

### super关键字用法

1. 在子类的成员方法中，访问父类的成员变量
2. 在子类的成员方法当中，调用父类的成员方法
3. 在子类的构造器当中，调用父类的构造器

### this关键字用法

1. 在本类的成员方法中，访问本类的成员变量
2. 在本类的成员方法中，访问另一个成员方法
3. 在本类的构造方法中，访问本类的另一个构造方法（必须是第一句）

super和this的内存图

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190928142725322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyNDUyOTMyMDY=,size_16,color_FFFFFF,t_70)

## Java继承的三个特点

1. Java语言可以多级继承。
2. Java语言是单继承的。
直接父类只能有唯一一个

一个父类可以有多个子类

# 抽象

有方法，不确定如何执行

## 抽象方法和抽象类

抽象方法：public abstract void eat();

抽象类：抽象方法所在的类`必须`是抽象类
抽象类`可以`有正常方法

public abstract class Animal{
    public abstract void eat();
    public void method(){

    }
}

如何使用抽象类和抽象方法：
1. 不能直接new抽象对象
2. 必须用一个子类去继承父类
3. 抽象类的子类必须重写父类的抽象方法
4. 创建子类对象进行使用

注意：

抽象类可以有构造方法，为子类继承初始化成员变量
抽象类中不一定含抽象方法，但有抽象方法的类必定是抽象类
抽象类的所有方法必须在子类进行重写
`子类`也`可以`是抽象类

# 接口

接口是一种公共的规范标准

public interface 接口名称{
    接口内容
}

JAVA 7,
1. 常量
2. 抽象方法

java 8
3. 默认方法
4. 静态方法

java9：
5. 私有方法

注意：
1. 接口当中的抽象方法，修饰符必须是两个固定的关键字，public abstract
2. 这两个关键字修饰符，可以选择性省略（目前不推荐）

使用步骤:
1. public class name implements 接口名称
2. 接口的实现类必须覆盖重写接口中所有的抽象方法
3. 创建实现类的对象，进行使用
4. 若没有全部重写，那么它必须是抽象类

`java 8 开始支持默认方法`：
public `default` void methodDefault(){
    ...
}

static静态方法不能再实现类当中调用

而是用接口本身调用

`java 9 开始支持私有方法`，供静态方法自身调用

接口也可以定义成员变量，但必须是常量;用public static final来修饰

一个类可以同时实现`多个`接口，和`继承`作`比较`

有冲突的默认方法就进行重写

与父类的方法冲突，默认父类方法

接口与接口之间的多继承：
子接口继承自的多个父接口当中有`抽象方法冲突`：`无所谓`？因为没有方法体
子接口继承自的多个父接口当中有`默认方法冲突`：`覆盖重写`